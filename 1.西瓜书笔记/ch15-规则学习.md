# 第十五章 规则学习

1. “规则学习”（rule learning）是从训练数据中学习出一组能用于对未见示例进行判别的规则。**规则学习中的“规则”是狭义的，事实上约定俗成地省略了“逻辑”二字**。形式化地看，一条规则形如：
![20230614221645](https://cdn.jsdelivr.net/gh/Corner430/Picture1/images/20230614221645.png)
> 其中逻辑蕴含符号“$\leftarrow$”右边部分称为“规则体”（body），表示该条规则的前提，左边部分称为“规则头”（head），表示该条规则的结果。

2. 规则体是由逻辑文字（literal）$f_k$组成的合取式（conjunction），其中合取符号“∧”用来表示“并且”。每个文字$f_k$都是对示例属性进行检验的布尔表达式。

3. **规则学习有更好的可解释性**

4. **数理逻辑具有极强的表达能力**。因此，规则学习能更自然地在学习过程中引入领域知识。

5. 符合某条规则地样本称为被该规则“覆盖”（cover）。**需要注意的是，被正例规则覆盖的样本是正例，但没被正例规则覆盖的未必不是正例；只有被反例规则覆盖的样本才是反例**。

6. **显然，规则集合中的每条规则都可看作一个子模型，规则集合是这些子模型的一个集成**。

7. **当同一个示例被判别结果不同的多条规则覆盖时，称发生了“冲突”（conflict），解决冲突的办法称为“冲突消解”（conflict resolution）**。常用的冲突消解策略有投票法、排序法、元规则法等。

8. **从训练集学得的规则集合也许不能覆盖所有可能的未见示例，这种情况在属性数目很多时常出现。因此，规则学习算法通常会设置一条“默认规则”（default rule），由它来处理规则集合未覆盖的样本**。

9. 从形式语言表达能力而言，规则可分为两类：**“命题规则”（propositional rule）和“一阶规则”（first-order rule）**.
- 显然，**一阶规则能表达复杂的关系**，因此也被称为“关系型规则”（relational rule）
- 显然，从形式语言系统的角度来看，**命题规则是一阶规则的特例，因此一阶规则的学习比命题规则要复杂得多**

10. **规则学习的目标是产生一个能覆盖尽可能多的样例的规则集。最直接的做法是“序贯覆盖”(sequentialcovering)，即逐条归纳**：在训练集上每学到一条规则，就将该规则覆盖的训练样例去除，然后以剩下的训练样例组成训练集重复上述过程。由于每次只处理一部分数据，因此**也被称为“分治”(separate- and conquer)策略**.

11. **序贯覆盖（Sequential Covering）**是一种基于规则学习的机器学习方法，用于从数据中提取一组规则来描述数据之间的关系。它的目标是**生成一组简单而准确的规则，每个规则都能覆盖尽可能多的训练实例**。
- 序贯覆盖通常用于**监督学习**任务，其中训练数据包含输入特征和相应的输出标签。它逐步生成规则，每次生成一条规则并移除该规则覆盖的实例，然后再基于更新后的数据继续生成下一条规则。**这种逐步生成的过程可以确保每个规则都专注于不同的实例子集**。

- 下面是序贯覆盖的基本步骤：
  1. 初始化：准备训练数据集和一个初始规则集。
  2. 选择规则：从剩余的未覆盖实例中选择一个规则进行生成。**通常采用启发式方法**，如基于信息增益或基尼指数的特征选择来确定生成规则的顺序。
  3. 生成规则：针对选择的规则，根据数据的特征和标签生成规则的条件和结论。生成的规则应该足够简单、具有高准确性，并且能够覆盖尽可能多的实例。
  4. 移除实例：将被生成的规则覆盖的实例从数据集中移除，以确保下一个规则能够关注到其他未覆盖的实例。
  5. 终止条件：**检查终止条件，例如达到指定的规则数量、无法生成更多规则或覆盖率达到一定阈值等**。
  6. 重复生成：如果终止条件未满足，返回步骤2，选择下一个规则进行生成。
- 序贯覆盖的优点之一是生成的规则简单且易于解释，因为每个规则都是基于部分实例生成的，并且可以根据规则的覆盖情况来评估其重要性。然而，**序贯覆盖也有一些挑战，例如处理大规模数据集时的效率问题以及规则之间的重叠和冲突**。在实际应用中，可以使用一些技术来改进序贯覆盖算法，例如**剪枝、规则合并和后剪枝等**。

12. **一阶规则学习（First-Order Rule Learning）**是机器学习领域中的一种方法，用于从数据中学习一阶逻辑规则。与传统的规则学习方法相比，一阶规则学习能够处理更丰富和复杂的关系，包括对象之间的关联和属性之间的约束。

**一阶逻辑是一种用于描述关系和约束的形式化语言，它包含谓词（描述对象的性质或关系）、变量（代表对象）、常量（具体的对象）和逻辑连接词（如AND、OR、NOT等）。一阶规则学习的目标是通过学习从输入特征到输出标签的一阶逻辑规则来进行分类、预测或推理**。

以下是一阶规则学习的一般步骤：
  1. 数据准备：收集和准备用于学习的数据集，包括一组特征和相应的标签。
  2. 特征工程：根据任务和数据的特点，对输入特征进行处理和选择，以提取有意义的一阶逻辑约束。
  3. 规则生成：使用一阶规则学习算法从数据集中生成一阶逻辑规则。这通常包括确定规则的结构、选择谓词和变量，并确定规则的条件和结论。
  4. 规则评估：评估生成的规则对于新数据的预测能力。可以使用交叉验证或保留一部分数据进行评估。
  5. 规则应用：将生成的规则应用于新的未知实例，进行分类、预测或推理。
**一阶规则学习的优点之一是能够处理复杂的关系和约束，因为一阶逻辑具有丰富的表达能力。它可以应用于多个领域，包括自然语言处理、知识图谱构建、关系抽取等任务。然而，一阶规则学习也面临一些挑战，如处理大规模数据集的计算复杂性和过拟合问题**。近年来，一阶规则学习领域涌现出一些高效的算法和技术，如基于逻辑编程的方法、约束学习和归纳逻辑编程等，以改善一阶规则学习的效果和效率。

13. **归纳逻辑程序设计（Inductive Logic Programming，简称ILP）**是一种机器学习方法，**结合了一阶逻辑（First-Order Logic）和逻辑程序设计的思想，用于从数据中归纳出一组逻辑程序规则。ILP的目标是通过学习逻辑规则来解决基于背景知识的逻辑程序归纳问题，这些规则可以直接在逻辑程序设计语言（如PROLOG）中使用**。

- 在ILP中，背景知识以逻辑程序的形式给出，它包括一组事实、规则和约束，描述了问题领域的先验知识。ILP的任务是根据给定的背景知识和训练数据集，学习出一组逻辑规则，使得这些规则能够解释已知的数据，并具有一定的泛化能力。

- ILP的基本思想是通过在逻辑程序中插入变量和函数，使得规则可以通过归纳推理从例子中学习出来。ILP算法通常包括以下步骤：
  1. 定义背景知识：将问题的背景知识表示为逻辑程序，包括事实、规则和约束。
  2. 数据准备：收集和准备用于学习的训练数据集，其中每个示例由输入和输出标签组成。
  3. 候选规则生成：基于背景知识，生成候选的逻辑规则，这些规则包含变量和函数，以便进行归纳推理。
  4. 归纳推理：使用归纳推理算法，将候选规则与训练数据集进行匹配和推理，以找到满足数据的规则。
  5. 规则评估和修剪：评估生成的规则对于训练数据和背景知识的拟合程度，并进行修剪或组合，以提高规则的泛化能力。
  6. 输出规则：输出学得的逻辑规则，这些规则可以直接在逻辑程序设计语言中使用，例如PROLOG。

- 归纳逻辑程序设计具有强大的表达能力，能够处理复杂的关系和约束。它在领域知识比较充分、问题具有明确的逻辑结构的任务中表现出色，例如自然语言处理、关系抽取、知识图谱构建等。然而，由于ILP的计算复杂性较高，处理大规模数据和复杂问题时可能面临挑战。因此，研究者们一直在探索和改进ILP算法，以提高其效率和可扩展性。

